/**
  ******************************************************************************
  * File Name          : field_mode.c
  * Description        : This file .
  ******************************************************************************
  ** 
  * COPYRIGHT(c) 2017 CityTaps. All right reserved.
  *
  ******************************************************************************
  */
	
/** @addtogroup ctmeter_modes Modes
	* @{
	*/
	
/** @addtogroup ctmeter_modes_field Field
	* @{
	*/
	
	/* Includes ------------------------------------------------------------------*/
#include "stm32l0xx_hal.h"
#include "pulse_meter.h"
#include "variables.h"
#include "ctmeter.h"
#include "lid.h"
#include "eeprom.h"
#include "lora.h"
#include "field.h"
#include "communication.h"
#include "watchdog.h"
	
/* Private ---------------------------------------------------------*/

BOOL_StatusTypeDef		*get_test_var_wakeup_routine(void); // Sensing var here for dev only
static BOOL_StatusTypeDef	__joining_for_the_first_time(void);
static void				__handle_success(void);
static void				__handle_failure(ct_state *next_mode);
static void				__connect_to_the_network(ct_state *next_mode);
static void				__radio_wake_up(void);

static UPLK_StatusTypeDef __transmission_state;
static DWNLK_messageTypeDef __downlink_decoded_message;
static char __uplink_message[50];
static char __downlink_message[MAX_RESPONSE_LENGTH];
static BOOL_StatusTypeDef Flag_GotoStorageMode = BOOL_FALSE;	

BOOL_StatusTypeDef		*get_test_var_wakeup_routine(void) {
	static BOOL_StatusTypeDef test_var_wakeup_routine;

	return &test_var_wakeup_routine;
}

static void					__radio_wake_up(void) {
	*(get_test_var_wakeup_routine()) = BOOL_TRUE;
	loramodule_radioWakeup();
	HAL_Delay(DELAY_AFTER_LORAMODULE_OPERATIONS);
}

static BOOL_StatusTypeDef	__joining_for_the_first_time(void) {
	CTMeter	*meter;

	meter = CTMeter_get();
	if (meter->radio_status.first_join_network == 0)
		return BOOL_TRUE;
	return BOOL_FALSE;
}

static void				__mark_network_as_joined(void) {
	CTMeter	*meter;

	meter = CTMeter_get();

	if (__joining_for_the_first_time()) {
		meter->radio_status.first_join_network = 1;
		save_to_non_volatile_memory(FIRST_JOIN_NETWORK_TYPE, meter->radio_status.first_join_network);
	}
	meter->radio_status.nb_try_joining = 0;
}

static void				__handle_success(void) {
	CTMeter	*meter;

	meter = CTMeter_get();

	DEBUG("[FIELD] Connection to the network successful\n\r");
	if (!__joining_for_the_first_time()
		&& meter->error_flag != RESTART_CLEARED) {
			comms_sendRestartMessage(meter->error_flag);
	} else {
			comms_sendStartMessage();
	}
	__mark_network_as_joined();
}

static void				__handle_failure(ct_state *next_mode) {
	if (__joining_for_the_first_time()) {
		DEBUG("[FIELD] Connection to the network failed\n\r");
		/*
		 * We restart the loramodule to prevent having a "free
		 * channel" error after several connection attemps
		 */
		loramodule_radioReset();
		HAL_Delay(DELAY_AFTER_LORAMODULE_OPERATIONS);
		loramodule_radioSleep(LORAMODULE_MAX_SLEEP_DURATION);

		*next_mode = CTMETER_IN_STORAGE_MODE;
	} else {
		DEBUG("[FIELD] Connection to the network failed\r\n");
		CTMeter_Reset(RESTART_JOINERROR);
	}
}

static void		__connect_to_the_network(ct_state *next_mode) {
	CTMeter				*meter;
	BOOL_StatusTypeDef	buzzerUsage;

	meter = CTMeter_get();
	save_to_non_volatile_memory(CTSTATUS_TYPE, (uint32_t) CTMETER_IN_FIELD_MODE);

	buzzerUsage = __joining_for_the_first_time() == BOOL_TRUE ? BOOL_TRUE : BOOL_FALSE;

	if (!__joining_for_the_first_time()) {
		if (meter->radio_status.nb_try_joining >= MAXIMUM_NUMBER_OF_JOIN_ATTEMPT_BEFORE_NONETWORK) {
			*next_mode = CTMETER_IN_NONETWORK_MODE;
			return ;
		}
		++meter->radio_status.nb_try_joining;
	}

	if (meter->radio_status.awake_state == RADIO_SLEEP) {
		DEBUG("[FIELD] radio is sleeping\n\r");
		__radio_wake_up();
	}	

	if (comms_connectToNetwork(buzzerUsage) == BOOL_TRUE) {
		__handle_success();
	} else {
		__handle_failure(next_mode);
	}
}

	/* Public Functions ----------------------------------------------------------*/
	/**
  * @brief This function is called by the main to manage the STORAGE mode
  * 
  * @return ct_state : CTMETER_IN_FIELD_MODE
	* 									 CTMETER_IN_NONETWORK_MODE
	*										 CTMETER_IN_STORAGE_MODE
  */
	ct_state FieldMode_Run(void)
	{
		CTMeter	*meter;
		ct_state next_mode = CTMETER_IN_FIELD_MODE;

		meter = CTMeter_get();
		if (meter->radio_status.join_state == RADIO_NOT_JOINED) {
			__connect_to_the_network(&next_mode);
		} else {
		  /* It should execute the conditional statement every meter->message_interval (in seconds) */
      if (meter->events.EVT_Timer >= meter->message_interval/IWDG_REFRESH_UNIT_S){
				DEBUG("[MAIN] Flag timer: %d, message_interval/IWDG: %d\n", meter->events.EVT_Timer, meter->message_interval/IWDG_REFRESH_UNIT_S);
				DEBUG("[QUEUE]");
				/* Save CTMeter state in EEPROM */
				CTMeter_StoreCheckPoint();
				/*  Check if the CTMeter is properly installed */
				if(accelerometer_isOutsidethreshold(meter->accel_threshold) == BOOL_TRUE){
					/* Set a flag to know that the accelerometer is above the threshold 
					 * (This flag is used to build the ALERT_MSG) */
					meter->accelerometer_status = ACCEL_ABOVE_THRESHOLD;
					DEBUG("[MAIN] Meter is not properly installed\n");    
					if(__transmission_state.next_message_to_send == STATUS_MSG){
						__transmission_state.next_message_to_send = ALERT_MSG;
					}
				} else {
					/* Set a flag to know that the accelerometer is below the threshold
					 * (This flag is used to build the ALERT_MSG) */
					meter->accelerometer_status = ACCEL_BELOW_THRESHOLD;
				}
				/* Check the fuse of the water sensor power */
				meter->fuse_sen_status = fuse_getSensorStatus();
				if (meter->fuse_sen_status == FUSE_BLOWN){
					DEBUG("[FUSE] Fuse of water sensor power is blown\n");
					if(__transmission_state.next_message_to_send == STATUS_MSG){
						__transmission_state.next_message_to_send = ALERT_MSG;
					}
				} else {
					DEBUG("[FUSE] Fuse of water sensor power is intact\n");
				}
				/* Check the fuse of the motor power */
				meter->fuse_mot_status = fuse_getMotorStatus();
				if (meter->fuse_mot_status == FUSE_BLOWN){
					DEBUG("[FUSE] Fuse of motor power is blown\n");
					if(__transmission_state.next_message_to_send == STATUS_MSG){
						__transmission_state.next_message_to_send = ALERT_MSG;
					}
				} else {
					DEBUG("[FUSE] Fuse of motor power is intact\n");
				}
				/* Check the magnetic counter */
				if (meter->magnetic_counter > 0){
					if(__transmission_state.next_message_to_send == STATUS_MSG){
						__transmission_state.next_message_to_send = ALERT_MSG;
					}
				}
#ifndef PCB_0666_01
				if (get_LidState() == LID_OPEN) { 
					DEBUG("[FIELD] LID is open, sending an alert instead of a status_msg\n");
					if(__transmission_state.next_message_to_send == STATUS_MSG){
						__transmission_state.next_message_to_send = ALERT_MSG;
					}
				}
#endif
				/* Set flag for message */
				__transmission_state.pending_flag = BOOL_TRUE;
				DEBUG("[MAIN] Flag timer: %d / wake_inter/IWDG: %d\n", meter->events.EVT_Timer, meter->message_interval/IWDG_REFRESH_UNIT_S);
				meter->events.EVT_Timer = 0;
			}
			
			/* Check if there is no more credit */
			if (PulseMeter_GetIndex() >= PulseMeter_GetCeiling()){
				DEBUG("[MAIN] Index is above or equal to index ceiling\n");
				if(meter->valve_status == VALVE_OPEN){
					DEBUG("[MAIN] Next message to send is STATUS_MSG because index ceiling is reached\n");
					__transmission_state.pending_flag = BOOL_TRUE;
					__transmission_state.next_message_to_send = STATUS_MSG;
					meter->events.EVT_Timer = 0;		// Reset the timer
				}
				valve_close();
			}
			
			/* Check if the magnetic sensor was altered */
			if (meter->events.EVT_Magnetic_sensor > 0){
				meter->magnetic_counter += meter->events.EVT_Magnetic_sensor;
				DEBUG("[FIELD] Magnetic counter: %d\n", meter->magnetic_counter);
				meter->events.EVT_Magnetic_sensor = 0;
			}	
			
#ifndef PCB_0666_01			
			if (meter->lid_has_just_been_opened == BOOL_TRUE){
				DEBUG("[FIELD] Preparing for immediate send of LID alarm\n\r");
				meter->lid_has_just_been_opened = BOOL_FALSE;
				__transmission_state.next_message_to_send = ALERT_MSG;
				/* Want the msg to go now, so we set timeleft bfr msg to 0 */
				__transmission_state.pending_flag = BOOL_TRUE;
				/* Next msg is INTERVAL_TIME from now */
				meter->events.EVT_Timer = 0;
			}
#endif
			
			/* Check if there is an incoming message from the LoRa module */
			if (meter->events.EVT_Message_from_radio_module == 1){
				/* If we receive a denied from the LoRa module, we try to connect using
				ABP. If it is not possible we restart with RESTART_RADIODENIED */
				if(strstr((const char *) usartrx_buffer, "enied") != NULL) {
					/* Wake up radio */
					loramodule_radioWakeup();		// Wake up the Lora module
					HAL_Delay(DELAY_AFTER_LORAMODULE_OPERATIONS);
					/* Try to connect with ABP or restart the CTMeter*/
					if(loramodule_radioJoinABP() == BOOL_TRUE){
						meter->radio_status.send_state = RADIO_NOT_BUSY; // remove RADIO_BUSY flag after reception of command
						loramodule_radioSleep(0xFFFFFFFF);
					} else {
						CTMeter_Reset(RESTART_RADIODENIED);
					}
				}
				/* Checks if the message received from the LoRa module is 
						a downlink command */
				if(comms_isDownlinkMessage((char *) usartrx_buffer, __downlink_message) == BOOL_TRUE){
					/* Update the downlink message counter */
					meter->downlink_counter++;
					DEBUG("[FIELD] Downlink message counter: %d\n", meter->downlink_counter);
					save_to_non_volatile_memory(DOWNLINK_COUNTER_TYPE, meter->downlink_counter);		// Save the downlink counter in non volatile memory
					/* Process downlink message */
					comms_processDownlinkMessage(__downlink_message, &__transmission_state, & __downlink_decoded_message);
					/* Send an Acknowledgement message in 4min 
					 * Except if the downlink message is a GET_INFORMATION or a RESET_MCU */
					if (__downlink_decoded_message.message_number != (GET_INFORMATION | RESET_MCU)){
						/* If the downlink message is a GO_TO_STORAGE_MODE message, we cannot send the CTMeter 
						 * immediatly to Storage Mode because we need first to send un ACKNOWLEDGEMENT_MSG.
						 * Therefore we set a flag to BOOL_TRUE and once the ACKNOWLEDGEMENT_MSG is sent,
						 * we send the CTMeter to Storage Mode */
						if (__downlink_decoded_message.message_number == GO_TO_STORAGE_MODE){
							Flag_GotoStorageMode = BOOL_TRUE;
						}
						__transmission_state.next_message_to_send = ACKNOWLEDGEMENT_MSG;
						meter->message_interval = ACKNOWLEDGEMENT_INTERVAL;	// New message interval is 4min		
						meter->events.EVT_Timer = 0;		// Reset the timer
					}
				}
				meter->events.EVT_Message_from_radio_module = 0;
			}
			
			/* Send a message if there is anything to be sent */
			if (__transmission_state.pending_flag == BOOL_TRUE){
				if(comms_isTXavailable() == BOOL_TRUE){
					comms_buildMessage(__uplink_message, 50, &__transmission_state, & __downlink_decoded_message);
					comms_sendMessage(__uplink_message);
					__transmission_state.pending_flag = BOOL_FALSE;
					__transmission_state.next_message_to_send = STATUS_MSG;
					load_from_non_volatile_memory(MESSAGE_INTERVAL_TYPE, &meter->message_interval);		// Restore message interval
					if(meter->message_interval == 0){
						meter->message_interval = MESSAGE_INTERVAL_INIT;
					}
					/* If an ACKNOWLEDGEMENT_MSG has been sent for the GO_TO_STORAGE_MODE message, send the CTMeter to Storage Mode */
					if (Flag_GotoStorageMode == BOOL_TRUE){
						CTMeter_changeModeTo(CTMETER_IN_STORAGE_MODE);
						Flag_GotoStorageMode = BOOL_FALSE;
					}
				}		
			}
		}
		return next_mode;
	}

	/**
  * @}
  */
	
	/**
  * @}
  */
	
	/************************ (C) COPYRIGHT CityTaps *****END OF FILE****/
