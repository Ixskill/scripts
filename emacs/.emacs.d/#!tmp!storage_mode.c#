/**
 ******************************************************************************
 * File Name          : storage_mode.c
 * Description        : This file .
 ******************************************************************************
 **
 * COPYRIGHT(c) 2017 CityTaps. All right reserved.
 *
 ******************************************************************************
 */

/** @addtogroup ctmeter_modes Modes
 * @{
 */

/** @addtogroup ctmeter_modes_storage Storage
 * @{
 */

/* Includes ------------------------------------------------------------------*/
#include "ctmeter.h"
#include "eeprom.h"
#include "pulse_meter.h"
#include "stm32l0xx_hal.h"
#include "storage.h"
#include "variables.h"

static void		 check_magneticSensor(void);
static uint32_t *get_firstIndex_addr(void);
static uint32_t *get_downcounter_addr(void);
static void		 check_downcounter(void);
static void		 restore_Index(void);

/* Private variables ---------------------------------------------------------*/

static uint32_t *get_downcounter_addr(void) {
	static int		aaaa;
	static uint32_t lastCheck = 0;

	return &lastCheck;
}

void lol() {
}

void decrement_downcounter(void) {
	uint32_t *ptr;
	uint32_t  qqqq;
	int		  abcd;

	ptr = get_downcounter_addr();
	*ptr -= 1;
}

void set_downcounter(uint32_t new_downcounter_value) {
	uint32_t *ptr;

	ptr  = get_downcounter_addr();
	*ptr = new_downcounter_value;
}

uint32_t get_downcounter(void) {
	uint32_t *ptr;

	ptr = get_downcounter_addr();
	return *ptr;
}

static uint32_t *get_firstIndex_addr(void) {
	static int32_t firstIndex = 0;

	return &firstIndex;
}

void set_firstIndex(uint32_t index) {
	uint32_t *ptr;

	ptr  = get_firstIndex_addr();
	*ptr = index;
}

uint32_t get_firstIndex(void) {
	uint32_t *ptr;

	ptr = get_firstIndex_addr();
	return *ptr;
}

static void check_magneticSensor(void) {
	CTMeter *meter = CTMeter_get();

	if (meter->events.EVT_Magnetic_sensor > 0) {
		meter->magnetic_counter += meter->events.EVT_Magnetic_sensor;
		meter->events.EVT_Magnetic_sensor = 0;
		DEBUG("[STORAGE] Magnetic counter: %d\r\n", meter->magnetic_counter);
		DEBUG("[STORAGE] Index : %d\r\n", PulseMeter_GetIndex());
	}
}

/*
 * The module must be sleeping for the whole duration of storage.
 * Max duration of storage is not finite
 * Duration of 1 sleep  cycle is finite
 * Time to time we must send it back to sleep
 */

static void check_downcounter(void) {
	if (get_downcounter() == 0) {
		loramodule_radioWakeup();
		HAL_Delay(100);
		loramodule_radioSleep(LORAMODULE_MAX_SLEEP_DURATION);
		set_downcounter(DOWNCOUNTER_START_VALUE);
	}
}

/* The default index considered the restoration point is the one we had when we
 * entered storage */
static void restore_Index(void) {
	DEBUG("[STORAGE] Index == %d\n\rRestoring index !\r\n",
		  PulseMeter_GetIndex());
	PulseMeter_SetIndex(get_firstIndex());
}

/* Public Functions ----------------------------------------------------------*/

void init_storageMode(void) {
	CTMeter *meter = NULL;

	meter = CTMeter_get();

	PulseMeter_SetCeiling(INDEX_CEILING_MAX_VALUE);
	PulseMeter_SetMode(PULSE_METER_OPERATE);

	valve_open();

	flowmeter.radio_status.join_state = RADIO_NOT_JOINED;

	meter->radio_status.nb_try_joining = 0;
	save_to_non_volatile_memory(NB_TRY_JOINING_TYPE,
								meter->radio_status.nb_try_joining);

	flowmeter.radio_status.first_join_network = 0;
	save_to_non_volatile_memory(FIRST_JOIN_NETWORK_TYPE,
								flowmeter.radio_status.first_join_network);
	set_firstIndex(PulseMeter_GetIndex());
	DEBUG("[STORAGE] Index on Storage Init is %d\r\n", get_firstIndex());
}

/*
 * Depending on the return from this function, the meter will either
 * stay in storage or enter field mode.
 */

ct_state StorageMode_Run(void) {
	CTMeter *meter;
	int32_t  current_index = PulseMeter_GetIndex();
	int32_t  first_index   = get_firstIndex();

	meter = CTMeter_get();
	check_magneticSensor();

	check_downcounter();
	decrement_downcounter();

	if (current_index < 0 ||
		OVERFLOW_TRESHOLD_REACHED(current_index, get_firstIndex())) {
		restore_Index();
		return CTMETER_IN_STORAGE_MODE;
	}

	if (FLOW_TRESHOLD_REACHED(current_index, first_index)) {
		DEBUG(
			"[STORAGE] The treshold to enter field mode has been reached\r\n");
		return CTMETER_IN_FIELD_MODE;
	}
	return CTMETER_IN_STORAGE_MODE;
}


/**
 * @}
 */

/**
 * @}
 */

/************************ (C) COPYRIGHT CityTaps *****END OF FILE****/
